% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group-by-SpatVector.R
\name{group-by.SpatVector}
\alias{group-by.SpatVector}
\alias{group_by.SpatVector}
\alias{ungroup.SpatVector}
\title{Group a SpatVector by one or more variables}
\usage{
\method{group_by}{SpatVector}(.data, ..., .add = FALSE, .drop = dplyr::group_by_drop_default(.data))

\method{ungroup}{SpatVector}(x, ...)
}
\arguments{
\item{.data, x}{A SpatVector object. See \strong{Methods}.}

\item{...}{In \code{group_by()}, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate \code{mutate()} step before the \code{group_by()}.
Computations are not allowed in \code{nest_by()}.
In \code{ungroup()}, variables to remove from the grouping.}

\item{.add}{When \code{FALSE}, the default, \code{group_by()} will
override existing groups. To add to the existing groups, use
\code{.add = TRUE}.

This argument was previously called \code{add}, but that prevented
creating a new grouping variable called \code{add}, and conflicts with
our naming conventions.}

\item{.drop}{Drop groups formed by factor levels that don't appear in the
data? The default is \code{TRUE} except when \code{.data} has been previously
grouped with \code{.drop = FALSE}. See \code{\link[dplyr:group_by_drop_default]{group_by_drop_default()}} for details.}
}
\value{
A SpatVector object with an additional column \code{dplyr.group_vars}.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Most data operations are done on groups defined by variables. \code{\link[=group_by]{group_by()}}
takes an existing SpatVector and creates a new variable indicating the
corresponding groups. See \strong{Methods}.
}
\details{
See \strong{Details} on \code{\link[dplyr:group_by]{dplyr::group_by()}}.
}
\section{Methods}{


Implementation of the \strong{generic} \code{\link[dplyr:group_by]{dplyr::group_by()}} family functions for
SpatVectors.

Since the \code{SpatVector} class is a \strong{S4 class}, there is not a
straightforward way to add an additional class (as \code{grouped_df}) to the
object. Instead, the implementation on \pkg{tidyterra} consists on simply
create a new column \code{dplyr.group_vars} where the value for the first row
is a representation of the variables declared in \code{...} and the value for
the rest of rows is \code{NA}.

This column is used internally for deriving the requested groups on the
subsequent operations. Hence, \code{grouped_df} class (default behaviour in
\pkg{dplyr}) is substituted on this implementation by \code{x$dplyr.group_vars}.

Note that removing \code{x$dplyr.group_vars} would cause \pkg{tidyterra} to not
recognize the SpatVector as grouped. This is better achieved by using the
\code{\link[=ungroup]{ungroup()}} function.
}

\examples{

# TODO
}
\seealso{
\code{\link[dplyr:group_by]{dplyr::group_by()}}, \code{\link[dplyr:group_by]{dplyr::ungroup()}}

Other dplyr verbs that operate on pairs Spat*/data.frame:
\code{\link{filter-joins.SpatVector}},
\code{\link{mutate-joins.SpatVector}}

Other dplyr methods:
\code{\link{arrange.SpatVector}()},
\code{\link{distinct.SpatVector}()},
\code{\link{filter-joins.SpatVector}},
\code{\link{filter.Spat}},
\code{\link{glimpse.Spat}},
\code{\link{mutate-joins.SpatVector}},
\code{\link{mutate.Spat}},
\code{\link{pull.Spat}},
\code{\link{relocate.Spat}},
\code{\link{rename.Spat}},
\code{\link{select.Spat}},
\code{\link{slice.Spat}}
}
\concept{dplyr.methods}
\concept{dplyr.pairs}
